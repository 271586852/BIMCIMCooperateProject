{
  "version": 3,
  "sources": ["../../@here/quantized-mesh-decoder/src/index.js"],
  "sourcesContent": ["const QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n])\n\nfunction decodeZigZag (value) {\n  return (value >> 1) ^ (-(value & 1))\n}\n\nfunction decodeHeader (dataView) {\n  let position = 0\n  const header = {}\n\n  for (let [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32\n\n    header[key] = getter.call(dataView, position, true)\n    position += bytesCount\n  }\n\n  return { header, headerEndPosition: position }\n}\n\nfunction decodeVertexData (dataView, headerEndPosition) {\n  let position = headerEndPosition\n  const elementsPerVertex = 3\n  const vertexCount = dataView.getUint32(position, true)\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex)\n\n  position += Uint32Array.BYTES_PER_ELEMENT\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT\n  const elementArrayLength = vertexCount * bytesPerArrayElement\n  const uArrayStartPosition = position\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength\n\n  let u = 0\n  let v = 0\n  let height = 0\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true))\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true))\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true))\n\n    vertexData[i] = u\n    vertexData[i + vertexCount] = v\n    vertexData[i + vertexCount * 2] = height\n  }\n\n  position += elementArrayLength * 3\n\n  return { vertexData, vertexDataEndPosition: position }\n}\n\nfunction decodeIndex (buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount)\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount)\n  }\n\n  if (!encoded) {\n    return indices\n  }\n\n  let highest = 0\n\n  for (let i = 0; i < indices.length; ++i) {\n    let code = indices[i]\n\n    indices[i] = highest - code\n\n    if (code === 0) {\n      ++highest\n    }\n  }\n\n  return indices\n}\n\nfunction decodeTriangleIndices (dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition\n  const elementsPerVertex = 3\n  const vertexCount = vertexData.length / elementsPerVertex\n  const bytesPerIndex = vertexCount > 65536\n    ? Uint32Array.BYTES_PER_ELEMENT\n    : Uint16Array.BYTES_PER_ELEMENT\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex)\n  }\n\n  const triangleCount = dataView.getUint32(position, true)\n  position += Uint32Array.BYTES_PER_ELEMENT\n\n  const triangleIndicesCount = triangleCount * 3\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  )\n  position += triangleIndicesCount * bytesPerIndex\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  }\n}\n\nfunction decodeEdgeIndices (dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition\n  const elementsPerVertex = 3\n  const vertexCount = vertexData.length / elementsPerVertex\n  const bytesPerIndex = vertexCount > 65536\n    ? Uint32Array.BYTES_PER_ELEMENT\n    : Uint16Array.BYTES_PER_ELEMENT\n\n  const westVertexCount = dataView.getUint32(position, true)\n  position += Uint32Array.BYTES_PER_ELEMENT\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false)\n  position += westVertexCount * bytesPerIndex\n\n  const southVertexCount = dataView.getUint32(position, true)\n  position += Uint32Array.BYTES_PER_ELEMENT\n\n  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false)\n  position += southVertexCount * bytesPerIndex\n\n  const eastVertexCount = dataView.getUint32(position, true)\n  position += Uint32Array.BYTES_PER_ELEMENT\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false)\n  position += eastVertexCount * bytesPerIndex\n\n  const northVertexCount = dataView.getUint32(position, true)\n  position += Uint32Array.BYTES_PER_ELEMENT\n\n  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false)\n  position += northVertexCount * bytesPerIndex\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  }\n}\n\nfunction decodeVertexNormalsExtension (extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength\n  )\n}\n\nfunction decodeWaterMaskExtension (extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  )\n}\n\nfunction decodeMetadataExtension (extensionDataView) {\n  const jsonLength = extensionDataView.getUint32(0, true)\n\n  let jsonString = ''\n  for (let i = 0; i < jsonLength; ++i) {\n    jsonString += String.fromCharCode(extensionDataView.getUint8(Uint32Array.BYTES_PER_ELEMENT + i))\n  }\n\n  return JSON.parse(jsonString)\n}\n\nfunction decodeExtensions (dataView, indicesEndPosition) {\n  const extensions = {}\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return { extensions, extensionsEndPosition: indicesEndPosition }\n  }\n\n  let position = indicesEndPosition\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true)\n    position += Uint8Array.BYTES_PER_ELEMENT\n\n    const extensionLength = dataView.getUint32(position, true)\n    position += Uint32Array.BYTES_PER_ELEMENT\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength)\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView)\n\n        break\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView)\n\n        break\n      }\n      case 4: {\n        extensions.metadata = decodeMetadataExtension(extensionView)\n\n        break\n      }\n      default: {\n        console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength\n  }\n\n  return { extensions, extensionsEndPosition: position }\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n}\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n}\n\nexport default function decode (data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions)\n  const view = new DataView(data)\n  const { header, headerEndPosition } = decodeHeader(view)\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return { header }\n  }\n\n  const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition)\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return { header, vertexData }\n  }\n\n  const {\n    triangleIndices,\n    triangleIndicesEndPosition\n  } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition)\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return { header, vertexData, triangleIndices }\n  }\n\n  const {\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices,\n    edgeIndicesEndPosition\n  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition)\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    }\n  }\n\n  const { extensions } = decodeExtensions(view, edgeIndicesEndPosition)\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  }\n}\n"],
  "mappings": ";;;AAAA,IAAM,wBAAwB,oBAAI,IAAI;AAAA,EACpC,CAAC,WAAW,aAAa,iBAAiB;AAAA,EAC1C,CAAC,WAAW,aAAa,iBAAiB;AAAA,EAC1C,CAAC,WAAW,aAAa,iBAAiB;AAAA,EAE1C,CAAC,aAAa,aAAa,iBAAiB;AAAA,EAC5C,CAAC,aAAa,aAAa,iBAAiB;AAAA,EAE5C,CAAC,yBAAyB,aAAa,iBAAiB;AAAA,EACxD,CAAC,yBAAyB,aAAa,iBAAiB;AAAA,EACxD,CAAC,yBAAyB,aAAa,iBAAiB;AAAA,EACxD,CAAC,wBAAwB,aAAa,iBAAiB;AAAA,EAEvD,CAAC,0BAA0B,aAAa,iBAAiB;AAAA,EACzD,CAAC,0BAA0B,aAAa,iBAAiB;AAAA,EACzD,CAAC,0BAA0B,aAAa,iBAAiB;AAC3D,CAAC;AAED,SAAS,aAAc,OAAO;AAC5B,SAAQ,SAAS,IAAM,EAAE,QAAQ;AACnC;AAEA,SAAS,aAAc,UAAU;AAC/B,MAAI,WAAW;AACf,QAAM,SAAS,CAAC;AAEhB,WAAS,CAAC,KAAK,UAAU,KAAK,uBAAuB;AACnD,UAAM,SAAS,eAAe,IAAI,SAAS,aAAa,SAAS;AAEjE,WAAO,GAAG,IAAI,OAAO,KAAK,UAAU,UAAU,IAAI;AAClD,gBAAY;AAAA,EACd;AAEA,SAAO,EAAE,QAAQ,mBAAmB,SAAS;AAC/C;AAEA,SAAS,iBAAkB,UAAU,mBAAmB;AACtD,MAAI,WAAW;AACf,QAAM,oBAAoB;AAC1B,QAAM,cAAc,SAAS,UAAU,UAAU,IAAI;AACrD,QAAM,aAAa,IAAI,YAAY,cAAc,iBAAiB;AAElE,cAAY,YAAY;AAExB,QAAM,uBAAuB,YAAY;AACzC,QAAM,qBAAqB,cAAc;AACzC,QAAM,sBAAsB;AAC5B,QAAM,sBAAsB,sBAAsB;AAClD,QAAM,2BAA2B,sBAAsB;AAEvD,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,SAAS;AAEb,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,SAAK,aAAa,SAAS,UAAU,sBAAsB,uBAAuB,GAAG,IAAI,CAAC;AAC1F,SAAK,aAAa,SAAS,UAAU,sBAAsB,uBAAuB,GAAG,IAAI,CAAC;AAC1F,cAAU,aAAa,SAAS,UAAU,2BAA2B,uBAAuB,GAAG,IAAI,CAAC;AAEpG,eAAW,CAAC,IAAI;AAChB,eAAW,IAAI,WAAW,IAAI;AAC9B,eAAW,IAAI,cAAc,CAAC,IAAI;AAAA,EACpC;AAEA,cAAY,qBAAqB;AAEjC,SAAO,EAAE,YAAY,uBAAuB,SAAS;AACvD;AAEA,SAAS,YAAa,QAAQ,UAAU,cAAc,eAAe,UAAU,MAAM;AACnF,MAAI;AAEJ,MAAI,kBAAkB,GAAG;AACvB,cAAU,IAAI,YAAY,QAAQ,UAAU,YAAY;AAAA,EAC1D,OAAO;AACL,cAAU,IAAI,YAAY,QAAQ,UAAU,YAAY;AAAA,EAC1D;AAEA,MAAI,CAAC,SAAS;AACZ,WAAO;AAAA,EACT;AAEA,MAAI,UAAU;AAEd,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,QAAI,OAAO,QAAQ,CAAC;AAEpB,YAAQ,CAAC,IAAI,UAAU;AAEvB,QAAI,SAAS,GAAG;AACd,QAAE;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,sBAAuB,UAAU,YAAY,uBAAuB;AAC3E,MAAI,WAAW;AACf,QAAM,oBAAoB;AAC1B,QAAM,cAAc,WAAW,SAAS;AACxC,QAAM,gBAAgB,cAAc,QAChC,YAAY,oBACZ,YAAY;AAEhB,MAAI,WAAW,kBAAkB,GAAG;AAClC,gBAAY,gBAAiB,WAAW;AAAA,EAC1C;AAEA,QAAM,gBAAgB,SAAS,UAAU,UAAU,IAAI;AACvD,cAAY,YAAY;AAExB,QAAM,uBAAuB,gBAAgB;AAC7C,QAAM,kBAAkB;AAAA,IACtB,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,cAAY,uBAAuB;AAEnC,SAAO;AAAA,IACL,4BAA4B;AAAA,IAC5B;AAAA,EACF;AACF;AAEA,SAAS,kBAAmB,UAAU,YAAY,4BAA4B;AAC5E,MAAI,WAAW;AACf,QAAM,oBAAoB;AAC1B,QAAM,cAAc,WAAW,SAAS;AACxC,QAAM,gBAAgB,cAAc,QAChC,YAAY,oBACZ,YAAY;AAEhB,QAAM,kBAAkB,SAAS,UAAU,UAAU,IAAI;AACzD,cAAY,YAAY;AAExB,QAAM,cAAc,YAAY,SAAS,QAAQ,UAAU,iBAAiB,eAAe,KAAK;AAChG,cAAY,kBAAkB;AAE9B,QAAM,mBAAmB,SAAS,UAAU,UAAU,IAAI;AAC1D,cAAY,YAAY;AAExB,QAAM,eAAe,YAAY,SAAS,QAAQ,UAAU,kBAAkB,eAAe,KAAK;AAClG,cAAY,mBAAmB;AAE/B,QAAM,kBAAkB,SAAS,UAAU,UAAU,IAAI;AACzD,cAAY,YAAY;AAExB,QAAM,cAAc,YAAY,SAAS,QAAQ,UAAU,iBAAiB,eAAe,KAAK;AAChG,cAAY,kBAAkB;AAE9B,QAAM,mBAAmB,SAAS,UAAU,UAAU,IAAI;AAC1D,cAAY,YAAY;AAExB,QAAM,eAAe,YAAY,SAAS,QAAQ,UAAU,kBAAkB,eAAe,KAAK;AAClG,cAAY,mBAAmB;AAE/B,SAAO;AAAA,IACL,wBAAwB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,6BAA8B,mBAAmB;AACxD,SAAO,IAAI;AAAA,IACT,kBAAkB;AAAA,IAAQ,kBAAkB;AAAA,IAAY,kBAAkB;AAAA,EAC5E;AACF;AAEA,SAAS,yBAA0B,mBAAmB;AACpD,SAAO,kBAAkB,OAAO;AAAA,IAC9B,kBAAkB;AAAA,IAClB,kBAAkB,aAAa,kBAAkB;AAAA,EACnD;AACF;AAEA,SAAS,wBAAyB,mBAAmB;AACnD,QAAM,aAAa,kBAAkB,UAAU,GAAG,IAAI;AAEtD,MAAI,aAAa;AACjB,WAAS,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AACnC,kBAAc,OAAO,aAAa,kBAAkB,SAAS,YAAY,oBAAoB,CAAC,CAAC;AAAA,EACjG;AAEA,SAAO,KAAK,MAAM,UAAU;AAC9B;AAEA,SAAS,iBAAkB,UAAU,oBAAoB;AACvD,QAAM,aAAa,CAAC;AAEpB,MAAI,SAAS,cAAc,oBAAoB;AAC7C,WAAO,EAAE,YAAY,uBAAuB,mBAAmB;AAAA,EACjE;AAEA,MAAI,WAAW;AAEf,SAAO,WAAW,SAAS,YAAY;AACrC,UAAM,cAAc,SAAS,SAAS,UAAU,IAAI;AACpD,gBAAY,WAAW;AAEvB,UAAM,kBAAkB,SAAS,UAAU,UAAU,IAAI;AACzD,gBAAY,YAAY;AAExB,UAAM,gBAAgB,IAAI,SAAS,SAAS,QAAQ,UAAU,eAAe;AAE7E,YAAQ,aAAa;AAAA,MACnB,KAAK,GAAG;AACN,mBAAW,gBAAgB,6BAA6B,aAAa;AAErE;AAAA,MACF;AAAA,MACA,KAAK,GAAG;AACN,mBAAW,YAAY,yBAAyB,aAAa;AAE7D;AAAA,MACF;AAAA,MACA,KAAK,GAAG;AACN,mBAAW,WAAW,wBAAwB,aAAa;AAE3D;AAAA,MACF;AAAA,MACA,SAAS;AACP,gBAAQ,KAAK,6BAA6B,WAAW,EAAE;AAAA,MACzD;AAAA,IACF;AAEA,gBAAY;AAAA,EACd;AAEA,SAAO,EAAE,YAAY,uBAAuB,SAAS;AACvD;AAEO,IAAM,iBAAiB;AAAA,EAC5B,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,iBAAiB;AAAA,EACjB,aAAa;AAAA,EACb,YAAY;AACd;AAEA,IAAM,kBAAkB;AAAA,EACtB,iBAAiB,eAAe;AAClC;AAEe,SAAR,OAAyB,MAAM,aAAa;AACjD,QAAM,UAAU,OAAO,OAAO,CAAC,GAAG,iBAAiB,WAAW;AAC9D,QAAM,OAAO,IAAI,SAAS,IAAI;AAC9B,QAAM,EAAE,QAAQ,kBAAkB,IAAI,aAAa,IAAI;AAEvD,MAAI,QAAQ,kBAAkB,eAAe,UAAU;AACrD,WAAO,EAAE,OAAO;AAAA,EAClB;AAEA,QAAM,EAAE,YAAY,sBAAsB,IAAI,iBAAiB,MAAM,iBAAiB;AAEtF,MAAI,QAAQ,kBAAkB,eAAe,iBAAiB;AAC5D,WAAO,EAAE,QAAQ,WAAW;AAAA,EAC9B;AAEA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI,sBAAsB,MAAM,YAAY,qBAAqB;AAEjE,MAAI,QAAQ,kBAAkB,eAAe,aAAa;AACxD,WAAO,EAAE,QAAQ,YAAY,gBAAgB;AAAA,EAC/C;AAEA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,kBAAkB,MAAM,YAAY,0BAA0B;AAElE,MAAI,QAAQ,kBAAkB,eAAe,YAAY;AACvD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,EAAE,WAAW,IAAI,iBAAiB,MAAM,sBAAsB;AAEpE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;",
  "names": []
}
